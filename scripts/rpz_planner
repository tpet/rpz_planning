#!/usr/bin/env python
"""RPZ compliant planner."""
from __future__ import absolute_import, division, print_function
# from exploration.msg import Path
from geometry_msgs.msg import Pose, PoseStamped, Pose2D, Quaternion, Transform, TransformStamped, Twist
from nav_msgs.msg import Path
import numpy as np
import rospy
from ros_numpy import msgify, numpify
from scipy.spatial import cKDTree
from sensor_msgs.msg import CameraInfo, PointCloud2
import tf2_ros
from threading import RLock
from timeit import default_timer as timer
import torch
import torch.nn.functional as fun
from visualization_msgs.msg import Marker, MarkerArray
from yacs.config import CfgNode


# https://github.com/rbgirshick/yacs
cfg = CfgNode()
cfg.visibility_sphere_radius = 100.


np.set_printoptions(precision=2)


def cloud_to_rpz_tensor(msg):
    assert isinstance(msg, PointCloud2)
    print('RPZ cloud (%i, %i) received, channels %s.'
          % (msg.height, msg.width, ', '.join([f.name for f in msg.fields])))

    cloud = numpify(msg)
    assert 'x' in cloud
    assert 'roll_0' in cloud
    assert 'pitch_0' in cloud
    assert 'z_0' in cloud

    # TODO: Create torch tensor of size (XD, YD, YawD, RPZ).
    # XD, YD is DEM size.
    # YawD is num. of quantized yaw levels, currently YawD = 8,
    # RPZ = 3 are roll, pitch, z.

    # Check point order.
    for i in range(min(10, cloud.size)):
        print('Point %i: (%.2f, %.2f)' % (i, cloud['x'][i], cloud['y'][i]))

    # torch.tensor()


def smooth_rpz(sigma):
    # TODO: torch.nn.Conv3d
    # padding_mode='circular' for yaw
    # padding_mode='zeros' for xy
    # Use circular as the values near xy edges are often garbage anyway.
    pass


def interpolate_rpz(rpz, xyy):
    # TODO: Interpolate roll, pitch, z for given x, y, yaw.
    # TODO: https://pytorch.org/docs/master/nn.functional.html#grid-sample
    # mode = 'bilinear' | 'nearest' | 'bicubic'
    # padding_mode = 'zeros' | 'border' | 'reflection'
    # Circular padding mode not supported.
    # TODO: Create YawD + 2 to wrap yaw for interpolation.
    pass


def point_visibility(pts, origin):
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html
    if isinstance(pts, np.ndarray):
        r = (pts - origin) ** 2
    if isinstance(pts, torch.Tensor):


    pass


def point_fov_mask(pts, cam):
    pass


def point_reward(pts, cam):
    pass


def slots(msg):
    """Return message attributes (slots) as list."""
    return [getattr(msg, var) for var in msg.__slots__]


def tf_to_pose(tf):
    # tf = Transform()
    pose = Pose()
    pose.position.x = tf.translation.x
    pose.position.y = tf.translation.y
    pose.position.z = tf.translation.z
    pose.orientation = tf.rotation
    return pose


def tf_to_pose_stamped(tf):
    tf = TransformStamped()
    pose = PoseStamped()
    pose.header = tf.header
    pose.pose = tf_to_pose(tf.transform)
    return pose


def p2e(xh):
    x = xh[:-1, :]
    return x


def e2p(x):
    xh = np.concatenate((x, np.ones((1, x.shape[1]))))
    return xh


class RPZPlanner(object):
    def __init__(self):
        self.map_frame = rospy.get_param('~map_frame', 'map')
        self.robot_frame = rospy.get_param('~robot_frame', 'base_footprint')
        self.max_age = rospy.get_param('~max_age', 1.0)

        # Keep only points inside a box for clearance check.
        # keep_cloud_box = rospy.get_param('~keep_cloud_box', [[-4.0, 4.0],
        #                                                      [-4.0, 4.0],
        #                                                      [-4.0, 4.0]])
        # self.keep_cloud_box = np.array(keep_cloud_box)
        # clearance_box = rospy.get_param('~clearance_box', [[-0.6, 0.6],
        #                                                    [-0.5, 0.5],
        #                                                    [ 0.0, 0.8]])
        # self.clearance_box = np.array(clearance_box)
        # self.show_clearance = rospy.get_param('~show_clearance_pos', [-10, 10])
        # self.min_points_obstacle = rospy.get_param('~min_points_obstacle', 1)

        self.num_cameras = rospy.get_param('~num_cameras', 1)

        # Latest RPZ manifold
        # TODO: frame vs map
        self.rpz_lock = RLock()
        self.rpz_msg = None
        self.rpz = None

        # Latest point cloud map to cover
        self.map_lock = RLock()
        self.map_msg = None
        self.map = None  # n-by-3 cloud position array
        # self.map_x_index = None  # Index of above

        self.tf = tf2_ros.Buffer()
        self.tf_sub = tf2_ros.TransformListener(self.tf)

        self.path_pub = rospy.Publisher('optimized_path', Path, queue_size=2)
        # self.clearance_pub = rospy.Publisher('clearance', MarkerArray, queue_size=2)

        # Allow multiple cameras.
        self.cam_info_lock = RLock()
        self.cam_infos = [None] * self.num_cameras
        self.cam_info_subs = [rospy.Subscriber('camera_info_%i' % i, CameraInfo,
                                               lambda msg, i=i: self.cam_info_received(msg, i), queue_size=2)
                              for i in range(self.num_cameras)]

        self.rpz_sub = rospy.Subscriber('rpz', PointCloud2, self.rpz_received, queue_size=2)
        self.map_sub = rospy.Subscriber('map', PointCloud2, self.map_received, queue_size=2)
        self.path_sub = rospy.Subscriber('path', Path, self.path_received, queue_size=2)

    def lookup_transform(self, target_frame, source_frame, time,
                         no_wait_frame=None, timeout=0.0):

        timeout = rospy.Duration.from_sec(timeout)
        if no_wait_frame is None or no_wait_frame == target_frame:
            tf_s2t = self.tf.lookup_transform(target_frame, source_frame, time, timeout=timeout)
            return tf_s2t

        # Try to get exact transform from no-wait frame to target if available.
        # If not, use most recent transform.
        dont_wait = rospy.Duration.from_sec(0.0)
        try:
            tf_n2t = self.tf.lookup_transform(target_frame, self.odom_frame, time, timeout=dont_wait)
        except tf2_ros.TransformException as ex:
            tf_n2t = self.tf.lookup_transform(target_frame, self.odom_frame, rospy.Time(0))

        # Get the exact transform from source to no-wait frame.
        tf_s2n = self.tf.lookup_transform(self.odom_frame, source_frame, time, timeout=timeout)

        tf_s2t = TransformStamped()
        tf_s2t.header.frame_id = target_frame
        tf_s2t.header.stamp = time
        tf_s2t.child_frame_id = source_frame
        tf_s2t.transform = msgify(Transform,
                                  np.matmul(numpify(tf_n2t.transform),
                                            numpify(tf_s2n.transform)))
        return tf_s2t

    def get_robot_pose(self, target_frame):
        tf = self.lookup_transform(target_frame, self.robot_frame, rospy.Time.now(),
                                   timeout=0.5, no_wait_frame=self.odom_frame)
        pose = tf_to_pose(tf.transform)
        return pose

    def clear_path(self):
        with self.path_lock:
            self.path_msg = None
            self.path = None
            self.path_x_index = None

    def cam_info_received(self, msg, i):
        """Store camera calibration for i-th camera."""
        assert isinstance(msg, CameraInfo)
        assert isinstance(i, int)
        with self.cam_info_lock:
            self.cam_infos[i] = msg

    def rpz_received(self, msg):
        """Process and store RPZ manifold for use in planning."""
        assert isinstance(msg, PointCloud2)
        with self.rpz_lock:
            self.rpz_msg = msg

    def map_received(self, msg):
        """Process and store map for use in planning."""
        assert isinstance(msg, PointCloud2)
        with self.map_lock:
            self.map_msg = msg

    def path_received(self, msg):
        assert isinstance(msg, Path)

        if not msg.header.frame_id:
            rospy.logwarn_once('Map frame %s will be used instead of empty path frame.',
                               self.map_frame)
            msg.header.frame_id = self.map_frame
        # elif not self.map_frame:
        #     self.map_frame = msg.header.frame_id
        elif self.map_frame and msg.header.frame_id != self.map_frame:
            rospy.logwarn_once('Map frame %s will be used instead of path frame %s.',
                               self.map_frame, msg.header.frame_id)

        # Discard old messages.
        age = (rospy.Time.now() - msg.header.stamp).to_sec()
        if age > self.max_age:
            rospy.logwarn('Discarding path %.1f s > %.1f s old.', age, self.max_age)
            return

        # TODO: Optimize path.
        # TODO: Publish optimized path.


if __name__ == '__main__':
    rospy.init_node('rpz_planner', log_level=rospy.DEBUG)
    node = RPZPlanner()
    rospy.spin()
